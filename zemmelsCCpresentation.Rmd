---
title: "`cmcR`: An open-source implementation of the Congruent Matching Cells method"
subtitle: "Creative Component Oral Exam"
author: "Joseph Zemmels"
institute: "Iowa State University"
date: "4/13/20"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
<style>
pre {
    display: block;
    font-family: monospace;
    white-space: pre;
    margin: 1em 0px;
    margin-top: 0em;
    margin-right: 0px;
    margin-bottom: 0em;
    margin-left: 0px;
}
</style>

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(cache.extra = knitr::rand_seed)
set.seed(3262020)
library(magrittr,cmcR)
```

```{r, load_refs, include=FALSE, cache=FALSE}
RefManageR::BibOptions(check.entries = FALSE,
           bib.style = "authoryear",
           cite.style = "alphabetic",
           style = "markdown",
           max.names = 2,
           no.print.fields = c("urldate","file","issn","url","keywords","language","abstract"),
           hyperlink = FALSE,
           dashed = FALSE)
myBib <- RefManageR::ReadBib("./ref.bib", check = FALSE)
```

#Overview

 - Motivation and Background Information
 
 - Pre-processing procedures
 
 - Cell-based comparison procedure
 
 - Congruent Matching Cells logic
 
 - Results & Discussion
 
 - Conclusion and Future Work

???
- This main goal of this project was to implement the Congruent Matching Cells method as originally proposed by John Song in 2013 as well as one improvement to the method proposed by Tong and others in 2014. The implementation is provided in the form of the `cmcR` package, currently available for download off of my Github.

- My plan for this presentation is to:
 - First introduce the problem and provide some exposition about the CMC method that will be expanded upon later
 - Discuss pre-processing steps that need to be performed on the cartridge case data in order to make the method work properly
 - Talk about the features we extract from the data for use in the method
 - Talk deeper about how we use the extracted features to make classification of matching vs. non-matching cartridge cases
 - Discuss results obtained from applying the method to commonly used cartridge case data in the CMC literature
 - Provide final conclusions and discuss future work

- While discussing various methods, I will be referring to associated functions in the `cmcR` package throughout the presentation. 

---
class: inverse, center, middle

# Motivation & Background Information

---

# Anatomy of a projectile

.pull-left[
1) Bullet

2) Cartridge case

3) Propellant

4) Rim

5) Primer
]

.pull-right[
```{r echo=FALSE,eval=TRUE,fig.align='right'}
knitr::include_graphics(path = "images/cartridgeCaseDiagram.png",dpi = 200)
```
]

.footnote[
[Image Source](https://commons.wikimedia.org/wiki/File:Bulletfixed.PNG)
]

???
- First, it's important to understand some common terminology.
- The diagram shows the entirety of what we might colloquially refer to as a "bullet." However, the bullet is actually only the projectile stored at the tip of the overall cartridge.
- We are most interested in the base of the cartridge case, the metal tube containing the bullet at at its neck and propellant inside. In particular, we are interested in the area around the primer.
- The primer is the region that is struck by the firing pin during the firing process.

---

# Breech face impressions

 - During firing process, cartridge case hits back wall (*breech face*) of barrel

 - Contact often "stamps" breech face markings onto cartridge case primer/base
 
.pull-left[
```{r echo=FALSE,eval=TRUE,fig.align='right',out.height=300,out.width=400}
knitr::include_graphics(path = "images/firearmBreechFace.png")
```
]

.pull-right[
```{r echo=FALSE,eval=TRUE,fig.align='right',out.height=300,out.width=400}
knitr::include_graphics(path = "images/cartridgeCasePrimer.png")
```
]

.footnote[
[Images Source](http://www.firearmsid.com/A_CCIDImpres.htm)
]

???
- During the firing process, as a bullet is propelled down the barrel of a firearm, the rest of the cartridge is sent backwards in response.
- The base of the cartridge case slams against the back wall, referred to as the breech face, of the firearm's barrel.
- Any markings left on the breech face due to, e.g., the manufacturing process can be "stamped" into the metal of the cartridge case base and primer.
- The two images illustrate this. The left image shows the breech face of a 12 gauge shotgun. We can clearly see some markings on this breech face.
 - The right image shows the primer of a spent cartridge case fired from this 12 gauge shotgun. We can see that some of the markings of the breech face have been imprinted onto this cartridge case.
- It has long been believed that a cartridge case can be matched to the firearm from which it was fired based on these breech face impressions. In particular, we may have a "questioned" cartridge case of unknown source that we can compare to a known-source cartridge case.

---
#Breech face vs. firing pin impressions

```{r echo=FALSE,eval=TRUE,fig.align='center',fig.retina=2.5}
knitr::include_graphics(path = "images/primerBFImpressionDiagram.png")
```

.footnote[
[Image Source](https://pdfs.semanticscholar.org/f2ab/001b090f2fcb79eff7a83b8aafeb81909944.pdf?_ga=2.260252488.476104195.1585242193-1176892230.1581362963)
]

???
- To match two cartridge cases, we are interested in comparing their breech face impressions.
- The image here shows that the breech face impression region of interest is actually rather small compared to the overall cartridge case base.
- Additionally, the impression left by the firing pin striking the primer is contained by the breech face impression region.
- Classifying matches based on markings left by the firing pin impression has also been explored. However, firing pin impressions are not the focus of the Congruent Matching Cells method.
---
# Cartridge case surface matrices

```{r echo=TRUE,eval=TRUE,strip.white=TRUE}
fadul1.1 <- x3ptools::read_x3p("data/Fadul 1-1.x3p")
```
```{r eval=FALSE}
x3ptools::image_x3p(fadul1.1)
```

```{r eval=TRUE,echo=FALSE,fig.align='center',fig.height=5}
#alternative:
fadul1.1 %>%
  # x3ptools::sample_x3p(m = 8) %>%
  .$surface.matrix %>%
  imager::as.cimg() %>%
  plot()
```

.footnote[
[Data Source](https://tsapps.nist.gov/NRBTD/Studies/Studies/Details/e7a8aab8-8d5a-44ac-b2be-f0de7c2ca505?nm=True&mt=1&m=3&sp=1)
]

???
- Cartridge case data typically come in two forms: optical 2D images and 3D topographical scans.
- It has been demonstrated by a number of authors that the 3D scans are easier to classify as matches vs. non-matches than the 2D images. The `cmcR` package was written to interface with the topographical scans.

- Many of these cartridge case scans are openly available from the NIST Ballistics and Toolmarks Research Database. The data are commonly stored in an XML 3D Surface Profile (or .x3p) file format. - The cartridge case data are represented in the .x3p file via a *surface matrix*. This is a single spatially-ordered matrix whose elements represent height values in micrometers (or *microns*) at a particular location. 
- It is these surface matrices with which we work directly when classifying matches. I will be referring to "cartridge case scans" and "surface matrices" synonymously.

- The `x3ptools` package in `R` can be used to interface with  .x3p files. The code shown will read an .x3p file into `R` and display it in 3D using a local `rgl` device. 
- The plot shown, while not the output of the `image_x3p` function, shows a representation of the contents of the surface matrix where height values are mapped to grayscale. 
 - Note that lighter colored pixels represent higher values than darker pixels. You can see that the area of the primer surrounding the firing pin impression is elevated relative to the rest of the cartridge case scan.
 - Note also that purely white pixels like those on the edges of the image shown are all `NA` or missing values. This will be important to remember later on.

---

# Congruent Matching Cells method

 - Some regions of cartridge case contain strong *ballistic signature*
 
 - Comparing entire scans may not highlight *valid correlation areas*<sup>[1]</sup>
 
 - Number of matching cells is a more granular similarity metric

```{r echo=FALSE,eval=TRUE,fig.align='center',fig.retina=2}
knitr::include_graphics(path = "images/im1_im2_cellComparison.png")
```

.footnote[
[1] `r RefManageR::Citet(myBib,7)`
]

???
- The Congruent Matching Cells method was a method proposed by John Song at NIST in 2013 to perform cartridge case identification.
- The motivation for the method is that it is common for only some regions of the cartridge case to come into contact with the firearm's breech face. As such, only some regions of the scan contain strong *ballistic signature* that can be used to identify matches.
- Rather than comparing entire scans to each other, the Congruent Matching Cells method proposes breaking a scan up into a grid of cells. Each of these cells is compared to an associated region in the other cartridge case scan.
- The image below illustrates this idea with a particular cell/region pair near the top-left corner of the scan.
- Counting the number of highly similar cells is a more granular similarity metric than, say, a single correlation calculated across the entirety of a scan.

---
#Congruent Matching Cells method

- Two surface matrices aligned through translation by $(dx,dy)$ and rotation by $\theta$.
 
    - $\pmb{\beta} \equiv (dx,dy,\theta)' \in \mathbb{R} \times \mathbb{R} \times [0,360)$ aligns surface matrix 1 to surface matrix 2

--

- Cartridge cases' cell/region pairs also be aligned

    - $\pmb{\beta}_i \equiv (dx_i,dy_i,\theta_i)', i = 1,...,n$ for $n$ total pairs

--

- We expect $\pmb{\beta}_i = \pmb{\beta}, \forall i = 1,...,n$ for true matches
 
- It's tractable to determine whether $\hat{\pmb{\beta}}_i \approx \hat{\pmb{\beta}}_j, i \neq j$
 
- Use estimated alignment parameters, $\hat{\pmb{\beta}}_i$, as features to classify matches 

???
- This slide details the main idea behind why the Congruent Matching Cells method is a coherent way to identify cartridge case matches.
- In their raw format, two cartridge case scans may not be aligned correctly. In particular, one may need to be rotated/translated to align with the other.
 - We'll refer to the "true" alignment parameters via a vector $\pmb{\beta}$
- If we consider one of the surface matrices split up into cells, we can also align each cell/region pair - call these "true" alignment parameters $\pmb{\beta}_i$
- If a pair of cartridge case cells is truly matching, we would expect the alignment parameters for each cell/region pair to agree with the alignment parameters for the overall scans.
- However, we don't actually know any of these "true" alignment parameters in practice. Instead, it's more tractable to determine whether estimated alignment parameters agree with each other across cell/region pairs, at least approximately.
- The Congruent Matching Cells method effectively proposes using the estimated alignment parameters as features to classify matches.

---
#Congruent Matching Cells method

```{r echo=FALSE}
knitr::include_graphics("images/bfRotationComparison.gif")
```

???
- To determine the estimated alignment parameters, each cell/region pair is compared for various rotations of one cartridge case scan.
- On the left of the GIF shown, we can see one cartridge case scan that has been divided into cells.
 - As an example, one of the cells near the top-left corner of the scan is paired with the region in the other scan that is highlighted in blue (it's somewhat difficult to see).
 - We can think of this as telling the cell in the left scan to watch a small window of the second scan as we rotate the scan.
 - For each rotation, we compare the cell in the first scan to whichever part of the second scan is in the window it was assigned.
 - Keep in-mind that the cell in the left scan stays fixed as well as the location of the region in the second scan. The only thing that changes is the part of the second scan that ends up in the region.

---
class: inverse, middle, center

# Pre-processing procedures

???
- Now we've laid some groundwork, we will begin discussing the actual implementation of the CMC method available in the `cmcR` package. 
- To illustrate usage of the package, I will combine explanations of the various procedures implemented as well as how to implement these procedures using various functions available in the `cmcR` package.
- We will discuss usage of the `cmcR` package in the same order that one might use the package to perform a cartridge case comparison.
 - That means starting with the procedures used to pre-process the scans before applying the method.
 - It's additionally important to discuss these pre-processing procedures because we have found that the CMC method is sensitive to how the data are prepared. Some discussion will be had related to this, but most results can be found in the Results & Discussion and Appendix of the Creative Component manuscript associated with the project. 
---

# Pre-processing goals

1) Remove regions of scan that do not contain breech face impressions
 
- Preferably do so automatically
     
2) Highlight remaining breech face impressions via Gaussian filtering
 

```{r echo=FALSE,fig.retina=3.5,fig.align='center'}
knitr::include_graphics("images/bfImpressionHighlighted.png")
```

???
- As previously discussed, the CMC method requires that the cartridge case scans be pre-processed in a variety of ways before being compared.
- The goal of pre-processing is two-fold:
 - For one, we want to automatically remove regions of the cartridge case scan that do not contain breech face impressions - at least not consistently. These regions are highlighted in red in the image shown.
 - Once these regions are removed, we want to "highlight" the remaining breech face impressions in some way while removing any other structure in a scan that may interfere with getting accurate similarity scores. A common way to do this when working with 3D topography data is with a Gaussian filter.

---

# 1. Identify BF impression height value

- RANSAC<sup>[1]</sup> (Random Sample Consensus) robust, iterative plane-fitting

.footnote[
[1] `r RefManageR::Citet(myBib,4)`
]

--

- Use RANSAC method to identify BF impression height value in scan

--

 - Take residuals between fitted plane and observed values within the final selection threshold specified

???
- The first step is to identify the height value in the scan at which the breech face impressions are. 
 - The RANSAC method is a robust plane-fitting method that works well when a trend in data is obscured by scatters of other data. 
 - This is certainly the case in cartridge case scans. In particular, the plateaued region caused by the firing pin impression striking the primer makes it difficult to find the breech face impression height value analytically.
- Once the RANSAC plane is fit, we can compute the residuals between the fitted plane and the observations and only take residuals within some final selection threshold as our "breech face impression" values.
 - This is analogous to removing a trend to a time series before modeling the residuals.

---

#1. Identify BF impression height value

```{r cache=TRUE,echo=TRUE}
fadul1.1 <- x3ptools::read_x3p("data/Fadul 1-1.x3p") %>%
  x3ptools::sample_x3p(m = 2)

fadul1.1$surface.matrix <- fadul1.1$surface.matrix %>%
  cmcR::preProcess_ransac(inlierTreshold = 10^-5,
                          finalSelectionThreshold = 2*(10^-5),
                          iters = 150) %>%
  cmcR::preProcess_levelBF(useResiduals = TRUE)
```
```{r eval=TRUE,echo=FALSE,fig.align='center',fig.height= 4.8}
#alternative:
fadul1.1 %>%
  # x3ptools::sample_x3p(m = 8) %>%
  .$surface.matrix %>%
  imager::as.cimg() %>%
  plot()
```

???
- The code on this slide first reads a cartridge case scan into `R` from an .x3p file and then downsamples the scan by a factor of 4 (i.e., samples every other row/column starting from the bottom left corner of the surface matrix).
 - This is done consistently in the CMC method literature, mainly for the sake of computational ease, and is recommended when using the `cmcR` package.
 - Results when using entire scans have been found to be comparable to these downsampled scans, although we don't currently have results on-hand.
- Once the scan is read into `R`, the ransac method is applied. The code shows how one might use the `cmcR` package functions to accomplish this.
- The plot then shows the output residuals after fitting the RANSAC plane.

Maybe skip these points:
 - The `inlierThreshold` controls how precise the estimated final plane is. The `finalSelectionThreshold` then dictates how far from the fitted plane an observation is allowed to be to call it part of the "breech face impressions."
- Then, the `preProcess_levelBF` function with the `useResiduals` argument set to `TRUE` will return the residuals between the RANSAC fitted plane and the cartridge case scan within the `finalSelectionThreshold` value (which is 2 microns).

---
#2. Removing "minutiae"

- Crop-out whitespace exterior to cartridge case scan

--

- Estimate radius of inner firing pin impression circle

--

- Use Hough transform circle detection method to detect and remove obserations within firing pin impression circle.


???
- As we can see on the previous slide, there are still some observations left after fitting the RANSAC method that aren't a part of the breech face impression region of interest.
- We can crop-out the observations in the corners of the surface matrix.
- Additionally, we can use a Hough transform circle detection method to find and remove observations left within the firing pin impression circle.
---
# 2. Removing "minutiae"

```{r cache=FALSE,echo=TRUE}
fadul1.1$surface.matrix <- fadul1.1$surface.matrix %>%
  cmcR::preProcess_cropWS(croppingThresh = 2) %>%
  cmcR::preProcess_removeFPCircle()
```

```{r echo=FALSE,fig.align='center',fig.height=6,cache=TRUE}
fadul1.1$surface.matrix %>%
  imager::as.cimg() %>%
  plot()
```

???
- We can see the output of cropping whitespace on the exterior of the scan and removing the firing pin impression circle observations on the interior on this slide.
- At the moment, this scan would be "ready" for the CMC method. However, performing an additional processing step by applying a Gaussian filter to the scan has been demonstrated to improve the method's classification accuracy.

---
#3. Gaussian filtering

- "Low-frequency", global structure due to, e.g., manufacturing specs

- "High-frequency" noise due to, e.g., scanning process

- Gaussian filtering reduces effects of large and small-scale structure

--
- Lowpass filtering = "smoothing"

    - Gaussian-weighted moving average

--

- Highpass filtering = "sharpening"

    - Subtract complementary lowpass-filtered matrix

--

- Bandpass filtering = highpass followed by lowpass

???
- There may exist some global "signal" in a cartridge case scan due to the way in which the cartridge case was manufactured.
 - We can refer to this as "low frequency" or "large wavelength" structure
- Additionally, noise may be inherent in a scan due to small measurement error in the scanning process.
 - These can be thought of as "high frequency" structure
- Neither of these structures are useful to us in making classifcations
- A Gaussian filter is a tool to lessen the effects of certain signals in a scan
- A low pass Gaussian filter can be thought of as performing a locally weighted moving average over a scan. This then "smooths" the scan and reduces the effects of high frequency noise.
- A high pass Gaussian filter, on the other hand, is meant to reduce the effects of low frequency signal. The term used for the effect such a filter has is to "sharpen" the image since high frequency signals become more apparent.
 - To implement a high frequency filter, one can subtract the complementary lowpass filtered surface matrix
- A bandpass filter combines a highpass and lowpass filter - thus reducing the effects signals that we don't want to consider in our comparisons

---
#3. Gaussian filtering

- Goal is to match cartridge cases based on *breech face impressions*, not on whether they share a manufacturer

--

- Structures are related to *subclass characteristics* that should not be used in making identifications

- False positive rate increases in test data if structures aren't removed 

???
- One might think that we want to include signal that could tie a cartridge case to a particular manufacturer.
- However, it's important to keep in-mind that we want to make classifications based on the breech face impressions (i.e., signal introduced from the firearm) rather than manufacturing specifications.
- We have seen evidence of an increase in the false positive rate if the low frequency signal is not removed prior to comparison. This makes sense since two cartridge cases fired from two different guns may have come from the same manufacturer, so not removing such information may lead us to make misclassifications.

---
#3. Gaussian filtering

```{r echo=TRUE,cache=TRUE}
fadul1.1$surface.matrix <- fadul1.1$surface.matrix %>%
  cmcR::preProcess_gaussFilter(res = fadul1.1$header.info$incrementY,
                               wavelength = c(16,250),
                               filtertype = "bp")
```
```{r echo=FALSE,fig.align='center',fig.height=5.5,cache=TRUE}
fadul1.1$surface.matrix %>%
  imager::as.cimg() %>%
  plot()
```

???
- This slide shows the output after applying a bandpass Gaussian filter to the signal.
- Note that there is basically a reciprocal relationship between the wavelengths we mean to target and the frequency (up to a scan resolution scaling constant).

---
#Pre-processing procedure conclusions

- Pre-processing procedures affect final results

- Methods used by some authors are still unavailable

    - Second-order robust Gaussian regression filter

    - Exact implementations may never be available

???
- To re-iterate, we have seen that the CMC method is highly dependent on the pre-processing procedures used prior to comparison.
- It is important to note that some methods are still unavailable to us, such as this second-order robust Gaussian regression filter, but current work is being done to try to implement this.
- Unfortunately, we may never have access to the exact implementations - which may make perfect replication of results impossible.

---
class: inverse, middle, center

# Cell-based comparison procedure

???
- Assuming that we have two fully processed scans, they are now ready to be compared using the cell-based comparison procedure briefly mentioned earlier.
- First, we must discuss what metrics we calculate during this comparison.

---
#Cross-correlation function

- For real-valued, bivariate funtions $f(x,y),g(x,y)$ for $x,y \in \mathbb{R}$, *cross-correlation function* (CCF) is

$$(f \star g)(x,y) := \int_{-\infty}^\infty \int_{-\infty}^\infty f(t,s) g(t + x,s + y)\ dtds$$

--

- **Discrete analogue:** For two discrete, bivariate functions $A[m,n], B[m,n]$ for $m,n \in \mathbb{Z}$, the CCF is

$$(A \star B)[m,n] := \sum_{i = -\infty}^\infty \sum_{j = -\infty}^\infty A[i,j] B[i + m,j + n]$$

--

- Think of $A[m,n]$ as $m$th row and $n$th column of matrix $A$

- $A$ and $B$ can be normalized so that CCF is between -1 and 1

???
- Similarity between a cell/region pair is measured using the cross-correlation function.
- For two real-valued, bivariate functions, the CCF is defined by the integral shown.
 - We can see that this integral is highly similar to the convolution between $f$ and $g$
 - Considering the integrand, this product can be calculated for various values of $(x,y)$. So we can picture calculating the integral of the product between functions $f$ and $g$ while sliding $g$ around 2-space.
 - With this mental picture, it seems intuitive that the CCF will be maximized when $f$ and $g$ are aligned to each other.
- The discrete analogue of the CCF is also given.
 - If we think of these discrete functions as matrices, then $[m,n]$ is the $m$th row and $n$th column of the matrix
 - Additionally, we can normalize $A$ and $B$ so that the CCF is between -1 and 1 and thus more interpretable.

---
#Cross-correlation theorem

- Calculating CCF from definition is computationally taxing

--

- By the Cross-correlation theorem,
$$A \star B = \mathcal{F}^{-1}\left(\overline{\mathcal{F}(A)} \cdot \mathcal{F}(B)\right)$$
 - $\mathcal{F}(\cdot)$ denotes Fourier transform
 
 - $\mathcal{F}^{-1}(\cdot)$ denotes inverse Fourier transform

 - $\overline{f}$ denotes complex conjugate of function $f$
 
 - product on RHS is element-wise (Hadamard) multiplication

--

- *Fast Fourier Transform* drastically improves computational efficiency<sup>[1]</sup>

.footnote[
[1] `r RefManageR::Citet(myBib,5)`
]

???
- It is computationally taxing to calculate the CCF from definition
- Instead, the Cross-correlation theorem allows us to instead consider calculating the CCF using Fourier transforms.
 - The important thing from the equation given is that we are calculating an element-wise product after Fourier transforming the two matrices $A$ and $B$. This is much faster than the moving product from the definition of the CCF.
 - The Fast Fourier Transform can be used to drastically improve computational time. In particular, we can exchange the moving product from the definition for essentially 3 Fourier transformations and an element-wise product.
 - I don't remember the actual computational complexity of the two procedures, but I know that calculating the CCF in this way is much faster.

---
#CCF alignment & missing values

- CCF indicates how one matrix should be translated to align with another

$$\text{CCF}_{\max} := \max_{m,n} \mathcal{F}^{-1}\left(\overline{\mathcal{F}(A)} \cdot \mathcal{F}(B)\right)[m,n]$$

$$[m^*,n^*] := \arg\max_{m,n} \mathcal{F}^{-1}\left(\overline{\mathcal{F}(A)} \cdot \mathcal{F}(B)\right)[m,n]$$

--

- Note: this method requires replacing missing/`NA` values

 - $\text{CCF}_{\max}$ values are often "deflated" for cartridge case scans
 
 - $[m^*,n^*]$ are often good estimates of "correct" translation parameters
 
--
 
- "True" $\text{CCF}_{\max}$ value, without replacing `NA`s, can be determined after aligning matrices by $[m^*,n^*]$

???
- So the CCF can be used to indicate how one matrix should be translated to align with another.
 - The $CCF_\max$ is just the maximum value attained by the CCF 
 - Additionally, the location where the $CCF_\max$ occurs tells us how to translate one matrix to align with another
- It's critical to note, however, that this Fourier transform-based method of calculating the CCF requires replacing missing values in a matrix
 - Recall that there are naturally *many* missing values in a surface matrix. It is common to replace missing values with the average value in the matrix.
 - The consequence of this is that the $CCF_\max$ values calculated in this way are often deflated for cartridge case scans. Thus, they are not accurate measures of similarity.
 - However, the translation values, $[m^*,n^*]$ at which the $CCF_\max$ value occurs are often good estimates of the correct translation parameters.
- After aligning two matrices by $[m^*,n^*]$, the "true" $CCF_\max$ can be calculated in which we don't replace missing values.

---
#CCF alignment - example

.pull-left[
```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/gaussianFilterInitialPlot.png")
```
]

.pull-right[
```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/ccfExample_im2.png")
```
]

```{r echo=FALSE,fig.align='center',dpi=170}
knitr::include_graphics("images/ccfExample_map.png")
```

???
- This slide shows an example that illustrates how to interpret the CCF.
- We can see that the two images are identical except that the white box in one has been translated to the top-left corner.
- The CCF, however, picks up on the correct translation to shift the right image back to the align with the left image.
- Note, however, that the CCF does not attain 1. This is because some Gaussian noise has been added to both.

---
# Cell-based comparison procedure

```{r echo=FALSE}
knitr::include_graphics("images/bfRotationComparison.gif")
```

???
- Now that we've developed an intuition for how we can compare two matrices, let's remind ourselves of the cell-based comparison procedure.
- It's intuitive to think of this as telling each cell in one scan to "watch" a region in the other scan as its being rotated. For each rotation value, we will record the $CCF_\max$ and associated translation values, $(dx,dy)$, for every cell/region pair, with some exclusions.

---
# Cell-based comparison procedure

1) Partition surface matrix 1 into grid of cells

--

2) Pair each cell in surface matrix 1 with its counterpart larger region in surface matrix 2.

--

3) For each rotation value:

- Rotate surface matrix 2 using linear interpolation scheme
  
--
    
- Remove from consideration cell/region pairs with too few observed values
  
--

- Shift and/or scale cells/regions (e.g., by respective average and/or standard deviation)
  
--
    
- Replace `NA` values with 0

--

- Calculate maximum cross-correlation function and associated $(dx,dy)'$ values using a FFT-based method

???
- Let's now actually step through the comparison procedure. This is the process we use to extract features from a cartridge case pair to make identifications, so its important to understand how we do so.

- Deciding whether cell/region pairs have too few observed values is loosely determined. The default is to throw away any pairs in which either matrix contains fewer than 15% of observed values.
- The shifting/scaling of the cell/region pairs does change the final results and is somewhat philosophically murky (how much do we want to tamper with the actual values in a surface matrix?). However, it seems that this is done at NIST.
- After shifting the cell/region pairs, their mean value should be 0. We can then replace missing values with 0.
---
#Cell-based comparison procedure

3) For each rotation value:

- Using $(dx,dy)'$ values, calculate pairwise-complete correlation between cell and a cell-sized matrix extracted from region in surface matrix 2

```{r echo=FALSE,fig.align='center',dpi=180}
knitr::include_graphics("./images/ccfCellPairExample.png")
```

???
- Once we get the $(dx,dy)$ values by which to translate a particular cell/region pair, we can calculate the "true" $CCF_\max$ by extracting a cell-sized matrix from the larger region in surface matrix 2.
- The plot on this slide shows the location of the cell-sized matrix that we can use to  calculate the pairwise-complete correlation as an orange square. The `CCF_max` value given in the table is calculated using the FFT-based method, so is not reliable.
---
# Cell-based comparison procedure

```{r echo=FALSE,eval=TRUE,cache=TRUE}
fadul1.2 <- x3ptools::read_x3p("~/bulletCartridgeScans/fadul_allScans/Fadul_1/cc/Fadul 1-2.x3p") %>%
  x3ptools::sample_x3p(m = 2)

fadul1.2$surface.matrix <- fadul1.2$surface.matrix %>%
  cmcR::preProcess_ransac(inlierTreshold = 10^-5,
                          finalSelectionThreshold = 2*(10^-5),
                          iters = 150) %>%
  cmcR::preProcess_levelBF(useResiduals = TRUE) %>%
  cmcR::preProcess_cropWS(croppingThresh = 2) %>%
  cmcR::preProcess_removeFPCircle() %>%
  cmcR::preProcess_gaussFilter(res = fadul1.2$header.info$incrementY,
                               wavelength = c(16,250),
                               filtertype = "bp")
```

```{r echo=TRUE,cache=TRUE}
comparison1 <- cmcR::cellCCF(fadul1.1,
                             fadul1.2,
                             thetas = seq(-30,30,by = 3),
                             cellNumHoriz = 8,
                             regionToCellProp = 4,
                             minObservedProp = .15,
                             centerCell = "individualCell",
                             scaleCell = "individualCell")
```
```{r eval=FALSE}
comparison1$ccfResults$`-30`
```


```{r echo=FALSE}
comparison1$ccfResults$`-30` %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling() %>%
  kableExtra::scroll_box(height = "200px")
```

???
- This slide shows the code to implement this cell-based comparison procedure using `cmcR`. 
 - We can see that we are considering a grid of $\theta$ values from -30 to 30.
 - Also, we are partitioning the first surface matrix into a grid of $8 \times 8$ cells. 
 - The corresponding regions will in the second surface matrix will be 4 times the size (double the side lengths) of their counterpart cells.
 
- The data frame shows the results of the cell-based comparison procedure when the second surface matrix was rotated by -30 degrees.
 - The `cellNum` columns provides the index starting from the top left corner moving right and down. 
 - The `cellID` column is the actual rows/columns in the overall surface matrix that each cell is taken from.
 - The `ccf` column is the pairwise-complete correlations calculated between a cell and the cell-sized matrix extracted from the cell's counterpart region in surface matrix 2.
 - The `fft.ccf` column is the CCF values calculated using the FFT method
 - The `dx` and `dy` columns are the translation values at which each `fft.ccf` values occurred.
 
- We have one of these data frames for each $\theta$ value considered.

---
class: inverse, middle, center

# Congruent Matching Cells logic

???
- We have now performed the cell-based comparison procedure between a pair of cartridge case scans.
- The Congruent Matching Cells method then provides us some guidance for how to take all of the information calculated using this procedure and actually use it to classify matches.
- Remember that we are using the estimated alignment parameters as features to classify matches
---
# Initially proposed method

- For each cell/region pair, determine alignment parameter estimates at which max CCF occurs

    - $\hat{\pmb{\beta}}_{\max,i}$ and $CCF_{\max,i}$ for $i = 1,....,n$ cells

- Cell/region pairs allowed to "vote" for a single set of alignment parameters

```{r cache=TRUE}
topResults <- cmcR::topResultsPerCell(comparison1$ccfResults)
```

???
- The first version of the method was proposed by John Song in 2013.
- In this initially proposed method, we only consider the alignment parameters at which the max CCF occurs. We'll call this $\beta{\max,i}$ for the $i$th cell/region pair
- We can think of this as only allowing each cell/region pair to "vote" for a particular set of alignment parameters.
- The function call shown will take the list of data frames that we've calculated using the cell-based comparison procedure and determine each cell/region pair's vote.
---
#Initially proposed method
```{r eval=FALSE}
topResults
```
```{r echo=FALSE}
topResults %>%
  dplyr::arrange(cellNum) %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling() %>%
  kableExtra::scroll_box(height = "400px")
# DT::datatable(topResults,
#               fillContainer = TRUE)
```

???
- This shows a data frame containing all of the top votes for each cell/region pair.
- If we focus specifically on, say, the $\theta$ values, we can see that many cell/region pairs voted for values around -24 degrees.
- We can also see the translation values, $(dx,dy)$, that each cell/region pair voted for.
---
# Initially proposed method

- Determine "consensus" among estimated alignment parameter values, $\bar{\pmb{\beta}}$

 - E.g., $\bar{\pmb{\beta}}$ is median of $\{\hat{\pmb{\beta}}_{\max,i}\}_{i = 1,...,n}$

--

- Classify cell/region pair as "congruent matching" if:

 - associated alignment parameter estimates are all close to consensual values and
 - $CCF_{\max,i}$ is greater than some threshold.

--

- $\left\lvert\hat{\pmb{\beta}}_{\max,i} - \bar{\pmb{\beta}}\right\rvert \leq \pmb{T}$ for thresholds $\pmb{T} = (T_{dx},T_{dy},T_{\theta})'$ and $CCF_{\max,i} \geq T_{CCF}$

 - Optimal $\pmb{T}, T_{CCF}$ determined through experimentation.

???
- The initially proposed method takes this data frame of top results and determines some consensus amongst the $(dx,dy,\theta)$ values.
 - We'll call this consensus $\bar{\pmb{\beta}}$.
 - We can, for example, take the median $(dx,dy,\theta)$ values reported in the `topResults` data frame.
- We then compare each cell/pairs vote to these consensual values. 
 - We call a cell/region pair "congruent matching" if the estimated alignment parameters are within some threshold distance of the consensual values AND if the $CCF_{\max,i}$ is greater than some threshold
- Note that the absolute value given here does not denote the Euclidean norm of a vector, but rather the absolute value of the individual elements of a vector.
 - So we are evaluating the inequality via the supremum norm (?). That is, *each* estimated translation parameter value needs to be within some distance of 

---
#Initially proposed method

```{r cache=TRUE}
initialCMCs <- topResults %>%
  cmcR::cmcFilter(consensus_function = median,
                  ccf_thresh = .6,
                  dx_thresh = 10,
                  theta_thresh = 3)
```
```{r eval=FALSE}
initialCMCs #8 initial CMCs
```

```{r echo=FALSE}
initialCMCs %>%
  dplyr::arrange(cellNum) %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling() %>%
  kableExtra::scroll_box(height = "300px")
```
 
???
- We can use the `cmcFilter` function to perform the initially proposed method's logic.
 - We need to define a consensus function and thresholds for the method to work.
 - Shown is one example of a combination of threshold values with which we have found success
- The data frame `initialCMCs` contains 8 CMCs determined under the initially proposed method.
 - We can see that the $\theta$ values are all relatively close to one another.
- Note that Song originally proposed using 6 CMCs as the minimum cut-off to classify a cartridge case pair as a "match." Under this criterion, we would call this pair particular pair a match.
 
---
# "Improved" method

- Cell pair may be highly similar at true $\pmb{\beta}$, but happened to not "vote" for it

--

- Use extracted features more advantageously & perform comparisons in both directions <sup>[1]</sup>
 
 - Comparison for surface matrix 1 vs. surface matrix 2 and vice versa

.footnote[
[1] `r RefManageR::Citet(myBib,6)`
]

--

- Calculate CMCs for *each* rotation value and identify CMC count modes

    - Define "high" CMC threshold, $\text{CMC}_{\text{high}} = \text{CMC}_{\max} - \tau$ for some $\tau$
    
    - Find $\theta$ value with associated count greater than or equal to $\text{CMC}_{\text{high}}$ furthest from $\theta$ value with associated count equal to $\text{CMC}_{\max}$.

--

- If "high CMC" $\theta$ values are too diffuse, then cartridge case pair likely not a match.

???
- Tong and others proposed an improvement to the initially proposed method in 2014.
- The main motivation behind this improved method a particular cell/region pair may be highly similar at the true alignment parameter value, but didn't happen to choose it for its top "vote."
 - Rather than only considering the top vote of a particular cell/region pair, the improved method uses the extracted information more advantageously, which will be discussed in more detail soon
 - Additionally, the improved method considers comparison in both "directions"
- Rather than applying the CMC logic to the top votes of each cell/region pair, the improved method applies this logic at each rotation value.
 - This is best explained visually, so an example is provided on the next slide
 - We can then identify a range of $\theta$ values constituting a CMC count mode
 - To identify a mode, we define a a "high" CMC threshold that is the max CMC count minus some $\tau$.
 - Then we determine the $\theta$ value with associated count greater than or equal to $\text{CMC}_{\text{high}}$ that is furthest from the $\theta$ value with associated count equal to $\text{CMC}_{\max}$. Effectively just trying to determine the spread of "high CMC" theta values.
 - If the "high CMC" $\theta$ values are too spread out, then the cell pair is likely not a match.
- An additional criterion placed on the cartridge case pairs is that the CMC count needs to attain definite mode in order for us to call the pair a match.

---
class: center
**Known match**
```{r echo=FALSE,fig.align='center',dpi=150}
knitr::include_graphics("images/kmCMCpertheta.png")
```

**Known non-match**
```{r echo=FALSE,fig.align='center',dpi=150}
knitr::include_graphics("images/knmCMCpertheta.png")
```

???
- This slide illustrates the idea behind the improved CMC method.
 - The 4 plots shown are the number of CMCs per rotation value for known match and known non-match pairs of cartridge cases across rotation values from -30 to +30 degrees
 - The number of CMCs have been calculated for both directions.
 - For the known match pair, we can clearly see that the CMC count attains a mode around -20 in one direction in +20 in the other.
 - Additionally, in the first plot, we can see that the only $\theta$ value with associated CMC count equal to $\text{CMC}_{\text{high}}$ is close to the $\theta$ value with associated CMC count equal to $\text{CMC}_{\max}$.
 - On the other hand, the known non-match plots show $\theta$ values that are much more diffuse. In particular, the range of $\theta$ values with associated CMC count greater than or equal to $\text{CMC}_{\text{high}}$ is much larger than that of the known match pair.
---
# "Improved" method

- If high CMC $\theta$ values are too diffuse, then assign CMC count based on initially proposed method

- Otherwise, count CMCs within `theta_thresh` of the $\theta$ value with associated count equal to $\text{CMC}_{\max}$ for both comparison directions

```{r echo=TRUE,cache=TRUE}
comparison2 <- cmcR::cellCCF_bothDirections(fadul1.1,fadul1.2,
                                            thetas = seq(-30,30,by = 3),
                                            cellNumHoriz = 8,
                                            regionToCellProp = 4,
                                            minObservedProp = .15,
                                            centerCell = "individualCell",
                                            scaleCell = "individualCell")

cmc <- comparison2 %>%
  cmcR::cmcFilter_improved(consensus_function = median,
                           ccf_thresh = .6,
                           dx_thresh = 10,
                           theta_thresh = 3)
```

???
- This slide shows code to both compare a pair of cartridge case scans in both directions and apply this improved logic to the result. 
---
# "Improved" method

```{r eval=FALSE}
cmc$finalCMCs #24 final CMCs
```
```{r echo=FALSE}
cmc$finalCMCs %>%
  dplyr::arrange(cellNum) %>%
  knitr::kable(format = "html") %>%
  kableExtra::kable_styling() %>%
  kableExtra::scroll_box(height = "400px")
```

???
- This slide then shows the "final" CMCs based on this improved method for the particular pair of cartridge case scans we've been considering.
---
```{r echo=TRUE,fig.height=3.2,fig.align='center',cache=TRUE}
cmcR::cmcPlot(fadul1.1,cmcDF = cmc$initialCMCs[[1]],method = "ggplot2")
```

```{r echo=TRUE,fig.height=3.2,fig.align='center',cache=TRUE}
cmcR::cmcPlot(fadul1.1,cmcDF = cmc$finalCMCs,method = "ggplot2")
```

???
- This slide provides visualizations of the initial and final CMCs using the `cmcPlot` function.
---
class: inverse, middle, center

# Results & Discussion

???
- We have now covered the implementation of the CMC method that is available in the `cmcR` package.
- From here, we will discuss how well results from this implementation compare to results provided from authors at NIST.

---
#Results & Discussion

- Fadul et al. 40 cartridge case scans<sup>[1]</sup>
    
    - 63 known match (KM) pairs, 717 known non-match (KNM) pairs

.footnote[
[1] `r RefManageR::Citet(myBib,8)`
]

--

- Goal: Separation between KM and KNM CMC count distributions
 
 <!-- - Common metric is distance between max KNM count and min KM count -->

--

- Sensitivity analysis under various pre, inter, and post-processing conditions

--

- Promising conditions are those used in this presentation

???
- Many authors in the CMC literature compare their results using a set of 40 cartridge case scans - 63 KMs and 717 KNMs
- We also used these data to compare our results
- Our overall goal is to attain complete separation between the KM and KNM CMC count distributions. This corresponds to perfect classification of the KM and KNM cartridge case pairs.
- Additionally, we were interested in determining how sensitive our implementation of the CMC method is to various pre, inter, and post-processing conditions.
 - These results are only briefly discussed here, but are provided in greater detail in the paper associated with this presentation.
- We used the same conditions used throughout this presentation when performing comparisons. 

---
#Initially proposed method results

```{r echo=FALSE,fig.align='center',dpi = 170}
knitr::include_graphics("images/initialCMCdistributions.png")
```

```{r echo=FALSE,fig.align='center',dpi = 170}
knitr::include_graphics("images/initialCMCroc.png")
```

???
- This slide shows the CMC count distribution for known match and known non-match pairs under the same conditions used in this presentation.
- We can see the KNM distribution in orange is located at low CMC values while the KM distribution in purple is more spread around higher CMC values.
 - There is some overlap between the KM and KNM distribution. In particular, KM pairs being assigned few CMCs.
- The ROC curve shown is constructed by changing the minimum CMC count needed to classify a pair as "matching." Visually, we can think of a vertical line moving horizontally along the CMC distribution where we call any pairs to the left of the line "non-matches" and to the right "matches."
- We can see because of the overlap between the KM and KNM distributions, perfect classification is not attainable.

---
# Initially proposed method sensitivity

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/initialCMCResidualsBP16_250plot_corr30-90_trans10-30_noAUC.png",dpi = 500)
```

???
- These plots show the CMC distributions under various combination of translation and ccf thresholds.
 - From top to bottom the CCF threshold becomes more restrictive. From left to right the translation threshold becomes less restrictive.
 - So the most restrictive conditions are those in the bottom left corner and least in the top right.
- These plots can be used to visually determine which thresholds yield the most promising results.
- For example, the plot on the previous page fits between the second and third row in the first column.
- The ROC curves associated with these 20 plots are given in the appendix.

---
# Initially proposed method discussion

- Perfect classification achieved under other alignment parameter thresholds<sup>[1]</sup>

.footnote[
[1] See appendix slides

[2] `r RefManageR::Citet(myBib,3)`, `r RefManageR::Citet(myBib,2)`
]

--

- Other authors achieve better separation of KM and KNM CMC distributions<sup>[2]</sup>

```{r echo=FALSE,fig.align='center',dpi = 240}
knitr::include_graphics("images/chenInitialCMCdistribution.PNG")
```


???
- It should be noted that although perfect classification was not attained under these particular conditions, the appendix shows an example of thresholds under which perfect classification was achieved.
- Additionally, it should also be noted that the original authors were able to achieve better separation between the KM and KNM distributions. We can likely chalk that up to their particular implementation.

---
#Improved method results

```{r echo=FALSE,fig.align='center',dpi = 170}
knitr::include_graphics("images/finalCMCdistributions.png")
```

```{r echo=FALSE,fig.align='center',dpi = 170}
knitr::include_graphics("images/finalCMCroc.png")
```

???
- This slide shows results for the improved method.
 - The major take aways from this are that (1) perfect classification is achieved, as indicated by the ROC curve.
 - However, both KNM and KM pairs are more often assigned a higher CMC value. This means more true *and* false positives.

---
# Improved method sensitivity

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/cmcResidualsBP16_250_corr30-90_trans10-30_noAUC.png",dpi = 500)
```

???
- This plot shows the behavior the "final" CMC distributions across various threshold combinations.
- We can see the improved method tends to give more CMCs to known matches, but also to known non-matches. In particular, a second "mode" of CMCs can be seen for the known non-matches in the first two rows of plots.
 - These can be chalked up to known non-matches that passed the additional "high CMC" criterion discussed previously. It's possible that small tweaks to the current implementation of the method may reduce if not eliminate these "false positives."

---
#Improved method discussion

- Improved method tends to assign higher CMC count to both KM and KNM

--

- More "false positive" CMCs assigned to KNM than other authors<sup>[1]</sup>

```{r echo=FALSE,fig.align='center',dpi = 175}
knitr::include_graphics("images/chenFinalCMCdistribution.PNG")
```


.footnote[
[1] `r RefManageR::Citet(myBib,2)`
]

???


---
# Results & Discussion

- Perfect classification achieved using both methods

 - Dependent on alignment parameter thresholds
 
 - See manuscript associated with this presentation for a deeper discussion on sensitivity of implementation.

--
 
- Other authors able to achieve better separation

--

- Explore small changes to methodology (e.g., parameter tuning) in future

---
class: inverse, middle, center

# Conclusions & Future Work

---
#Conclusions

- Results indicate a close implementation of proposed CMC methods

- Main issues related to separation between KM and KNM distributions

--

- Tuning of pre, inter, and post-processing conditions will undoubtedly lead to results closer to those of other authors

--

- Conditions used in this presentation are current `cmcR` package defaults

---
#Future Work

- **Short-term:**

    - `R` Journal submission

    - `cmcR` package submission to CRAN

- **Longer-term:**

    - CMC method improvments:
     - techniques for dealing with `NA`s
     - better classification diagnostics
     - implementation of closed-source methods

    - Principled approach to quantifying and/or modeling similarity

---
#References
```{r refs1, echo=FALSE, results="asis"}
RefManageR::PrintBibliography(myBib,end = 4)
```

---
#References (cont'd.)

```{r refs2, echo=FALSE, results="asis"}
RefManageR::PrintBibliography(myBib,start = 5)
```


---

class: center, middle

# Questions?

---
class: center, middle

# Thank you!

---
class: center, inverse, middle

# Appendix

---
# Initially proposed method perfect classif.

```{r echo=FALSE,fig.align='center',dpi = 170}
knitr::include_graphics("images/initialCMCdistributions_perfectClassification.png")
```

```{r echo=FALSE,fig.align='center',dpi = 170}
knitr::include_graphics("images/initialCMCroc_perfectClassification.png")
```

---
# Initial method CMC dist'n sensitivity

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/initialCMCResidualsBP16_250plot_corr30-90_trans10-30_noAUC.png",dpi = 500)
```

---
# Initial method ROC curve sensitivity

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/roc_initialCMC_residualsBP16-250_corr30-90_trans10-30.png",dpi = 500)
```


---
# Improved method CMC dist'n sensitivity

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/cmcResidualsBP16_250_corr30-90_trans10-30_noAUC.png",dpi = 500)
```

---
# Improved method ROC curve sensitivity

```{r echo=FALSE,fig.align='center'}
knitr::include_graphics("images/roc_residualsBP16-250.png",dpi = 500)
```
